#!/bin/ksh



err_exit() {
	print -u2 -- "$*"
	exit 1
}

usage() {
	err_exit "usage: ${0##*/} [-ax] [-f filename]"
}

wait_cgiinfo() {
	local _l _s _key _val

	if [ -f /tmp/cgipid ]; then
		wait "$(</tmp/cgipid)" 2>/dev/null
		rm -f /tmp/cgipid
	fi

	[[ -s $CGI_INFO ]] || return

	sed -En 's,^https?://([[A-Za-z0-9:_][]A-Za-z0-9:._-]*),\1,p' \
		$CGI_INFO >$HTTP_LIST 2>/dev/null

	read -r -- _s _l <$HTTP_LIST
	[[ -z $_l ]] && : ${HTTP_SERVER:=${_s%%/*}}

	while IFS='=' read -r -- _key _val; do
		case $_key=$_val in
		method=+([a-z])*([0-9]))	CGI_METHOD=$_val;;
		TIME=+([0-9]))			CGI_TIME=$_val;;
		TZ=+([-_/+[:alnum:]]))		CGI_TZ=$_val;;
		esac
	done <$CGI_INFO
}



isin() {
	local _a=$1 _b

	shift
	for _b; do
		[[ $_a == "$_b" ]] && return 0
	done
	return 1
}

addel() {
	local _a=$1

	shift
	isin "$_a" $* && echo "$*" || echo "${*:+$* }$_a"
}

rmel() {
	local _a=$1 _b _c

	shift
	for _b; do
		[[ $_a != "$_b" ]] && _c="${_c:+$_c }$_b"
	done
	echo "$_c"
}

bsort() {
	local _a _l

	set -s -- $@
	for _a; do
		_l=$(addel $_a $_l)
	done
	echo $_l
}

http_time() {
	local _sec=$(cat $HTTP_SEC 2>/dev/null)

	[[ -n $_sec && -n $CGI_TIME ]] &&
		echo $((CGI_TIME + SECONDS - _sec))
}

quote() (
	for _a; do
		alias Q=$_a; _a=$(alias Q); print -rn -- " ${_a#Q=}"
	done | sed '1s/ //'
	echo
)

show_cols() {
	local _l _cdir=/tmp/i/cdir _clist

	mkdir -p $_cdir
	rm -rf -- $_cdir/*
	while read _l; do
		[[ -n $_l ]] || continue
		mkdir -p /tmp/i/cdir/"$_l"
		_clist[${#_clist[*]}]="$_l"
	done
	(cd $_cdir; ls -Cdf "${_clist[@]}")
	rm -rf -- $_cdir
}

stripcom() {
	local _file=$1 _line

	[[ -f $_file ]] || return

	set -o noglob
	while read _line; do
		[[ -n ${_line%%#*} ]] && echo $_line
	done <$_file
	set +o noglob
}

tmpdir() {
	local _i=1 _dir

	until _dir="${1?}.$_i.$RANDOM" && mkdir -- "$_dir" 2>/dev/null; do
		((++_i < 10000)) || return 1
	done
	echo "$_dir"
}

unique_filename() {
	local _fn=$1 _ufn

	while _ufn=${_fn}.$RANDOM && [[ -e $_ufn ]]; do :; done
	print -- "$_ufn"
}

prep_root_mail() {
	local _fn=$1 _subject=$2 _ufn

	[[ -s $_fn ]] || return

	_ufn=$(unique_filename /mnt/var/log/${_fn##*/})
	cp $_fn $_ufn
	chmod 600 $_ufn
	_ufn=${_ufn#/mnt}

	cat <<__EOT >>/mnt/etc/rc.firsttime
( /usr/bin/mail -s '$_subject' root <$_ufn && rm $_ufn ) >/dev/null 2>&1 &
__EOT
}

lease_value() {
	local _lf=$1 _o _opt _val

	[[ -s $_lf ]] || return
	shift

	for _o; do
		while read -r _opt _val; do
			[[ $_opt == ${_o}: ]] && echo "$_val" && return
		done < "$_lf"
	done
}

dmesgtail() {
	dmesg | sed -n 'H;/^OpenBSD/h;${g;p;}'
}


diskinfo() {
	local _d _i _n _s

	for _d; do
		_i=$(dmesg | sed -n '/^'$_d' at /h;${g;s/^.*<\(.*\)>.*$/\1/p;}')
		_i=${_i##+([[:space:],])}
		_i=${_i%%+([[:space:],])}

		_n=$(dmesg | sed -En '/^'$_d' at /h;${g;s/^.* ([a-z0-9]+\.[a-zA-Z0-9_]+)$/\1/p;}')

		make_dev $_d
		_s=$(disklabel -dpg $_d 2>/dev/null | sed -n '/.*# total bytes: \(.*\)/{s//(\1)/p;}')
		rm -f /dev/{r,}$_d?

		echo "    $_d: $_i $_n $_s"
	done
}

make_dev() {
	[[ -z $(cd /dev && sh MAKEDEV "$@" 2>&1) ]]
}

scan_dmesg() {
	bsort $(sed -n "$1" $DMESGBOOT)
}

scan_disknames() {
	bsort $(IFS=,
        	for _d in $(sysctl -n hw.disknames); do
			echo "${_d%%:*} "
        	done | sed -n "$1")
}

get_softraid_chunks() {
	local _device=${1:-softraid0}

	[[ -x /sbin/bioctl ]] || return
	bioctl $_device 2>/dev/null | sed -n 's/.*<\(.*\).>$/\1/p'
}

get_softraid_volumes() {
	bioctl softraid0 | sed -n 's/^softraid0.*\(sd[0-9]*\).*/\1/p'
}

get_dkdevs() {
	scan_disknames "${MDDKDEVS:-/^[sw]d[0-9][0-9]* /s/ .*//p}"
}

get_cddevs() {
	scan_disknames "${MDCDDEVS:-/^cd[0-9][0-9]* /s/ .*//p}"
}

get_dkdevs_uninitialized() {
	local _disks=$(get_dkdevs) _d

	for _d in $DISKS_DONE $(get_softraid_chunks); do
		_disks=$(rmel "$_d" $_disks)
	done
	bsort $_disks
}

get_dkdevs_root() {
	local _disks=$(get_dkdevs) _d

	if [[ $MODE == upgrade ]]; then
		for _d in $_disks; do
			is_rootdisk "$_d" || _disks=$(rmel "$_d" $_disks)
		done
	fi
	echo $_disks
}

get_ifs() {
	local _if _if_list=$(rmel vlan $(ifconfig -C))

	for _if in $(ifconfig "$@" 2>/dev/null | sed '/^[a-z]/!d;s/:.*//'); do
		isin "${_if%%+([0-9])}" $_if_list || echo $_if
	done
}

if_name_to_lladdr() {
	local _lladdr

	_lladdr=$(ifconfig $1 2>/dev/null |
	    sed -n 's/^[[:space:]]*lladdr[[:space:]]//p')
	[[ -n $_lladdr && -n $(ifconfig -M "$_lladdr") ]] && echo $_lladdr
}

get_ifs_and_lladdrs() {
	local _if

	for _if in $(get_ifs); do
		echo $_if
		if_name_to_lladdr $_if
	done
}

get_dkdev_name() {
	local _dev=${1#/dev/} _d

	_dev=${_dev%.[${PARTITIONS}]}
	((${#_dev} < 16)) && _dev=${_dev%[${PARTITIONS}]}
	local IFS=,
	for _d in $(sysctl -n hw.disknames); do
		[[ $_dev == @(${_d%:*}|${_d#*:}) ]] && echo ${_d%:*} && break
	done
}

disk_has() {
	local _disk=$1 _pttype=$2 _part=$3 _cmd _p_pttype _p_part

	[[ -n $_disk && -n $_pttype ]] || exit

	local _c_hfs="pdisk -l $_disk"

	local _p_gpt='Usable LBA:'
	local _p_gpt_openbsd='^[ *]...: OpenBSD '
	local _p_gpt_apfsisc='^[ *]...: APFS ISC '
	local _p_gpt_biosboot='^[ *]...: BIOS Boot '
	local _p_gpt_efisys='^[ *]...: EFI Sys '
	local _p_hfs='^Partition map '
	local _p_hfs_openbsd=' OpenBSD OpenBSD '
	local _p_mbr='Signature: 0xAA55'
	local _p_mbr_openbsd='^..: A6 '
	local _p_mbr_dos='^..: 06 '
	local _p_mbr_dos_active='^\*.: 06 '
	local _p_mbr_linux='^..: 83 '

	eval "_cmd=\"\$_c_${_pttype}\""
	eval "_p_pttype=\"\$_p_${_pttype}\""
	eval "_p_part=\"\$_p_${_pttype}_${_part}\""

	_cmd=${_cmd:-fdisk $_disk}

	[[ -z $_p_pttype ]] && exit
	[[ -n $_part && -z $_p_part ]] && exit

	if [[ -z $_p_part ]]; then
		$_cmd 2>/dev/null | grep -Eq "$_p_pttype"
	else
		$_cmd 2>/dev/null | grep -Eq "$_p_pttype" &&
			$_cmd 2>/dev/null | grep -Eq "$_p_part"
	fi
}

disklabel_autolayout() {
	local _disk=$1 _f=$2 _dl=/tmp/i/disklabel.auto _op _qst

	[[ $_disk != $ROOTDISK ]] && return

	while $AI; do
		ask "URL to autopartitioning template for disklabel?" none
		[[ $resp == none ]] && break
		if ! $FTP_TLS && [[ $resp == https://* ]]; then
			err_exit "https not supported on this platform."
		fi
		echo "Fetching $resp"
		if unpriv ftp -Vo - "$resp" >$_dl && [[ -s $_dl ]]; then
			disklabel -T $_dl -F $_f -w -A $_disk && return
			err_exit "Autopartitioning failed."
		else
			err_exit "No autopartitioning template found."
		fi
	done

	_qst="Use (A)uto layout, (E)dit auto layout, or create (C)ustom layout?"
	while :; do
		echo "The auto-allocated layout for $_disk is:"
		disklabel -h -A $_disk | egrep "^#  |^  [${PARTITIONS}]:"
		ask "$_qst" a
		case $resp in
		[aA]*)	_op=-w;;
		[eE]*)	_op=-E;;
		[cC]*)	return 0;;
		*)	continue;;
		esac
		disklabel -F $_f $_op -A $_disk
		return
	done
}

configure_disk() {
	local _disk=$1 _fstab=/tmp/i/fstab.$1 _opt

	make_dev $_disk || return

	rm -f /tmp/i/*.$_disk
	md_prep_disklabel $_disk || return

	if ! grep -qs ' / ffs ' /tmp/i/fstab.$ROOTDISK; then
		echo "'/' must be configured!"
		$AI && exit 1 || return 1
	fi

	if [[ -f $_fstab ]]; then
		while read _pp _mp _rest; do
			if [[ $_mp == none ]]; then
				echo "$_pp $_mp $_rest" >>/tmp/i/fstab
				continue
			fi
			if [[ $_fstab != $(grep -l " $_mp " /tmp/i/fstab.*) ]]; then
				_rest=$_disk
				_disk=
				break
			fi
		done <$_fstab

		if [[ -z $_disk ]]; then
			cat /tmp/i/fstab.$_rest >/etc/fstab
			rm /tmp/i/fstab.$_rest

			set -- $(grep -h " $_mp " /tmp/i/fstab.*[0-9])
			echo "$_pp and $1 can't both be mounted at $_mp."
			$AI && exit 1 || return 1
		fi

		while read _pp _mp _fstype _rest; do
			[[ $_fstype == ffs ]] || continue

			if [[ $_mp == / ]]; then
				_opt=${MDROOTFSOPT:--O2}
			else
				_opt=${MDFSOPT:--O2}
			fi
			newfs -q $_opt ${_pp##/dev/}

			FSENT="$FSENT $_mp!$_pp"
		done <$_fstab
	fi

	return 0
}


lock() {
	while ! mkdir /tmp/i/lock 2>/dev/null && sleep .1; do :; done
}

unlock() {
	rm -df /tmp/i/lock 2>/dev/null
}

retrap() {
	trap '
		if [[ -f /tmp/cppid ]]; then
			kill -KILL -"$(</tmp/cppid)" 2>/dev/null
			rm -f /tmp/cppid
		fi
		echo
		stty echo
		exit 0
	' INT EXIT TERM
}

start_dmesg_listener() {
	local _update=/tmp/i/update

	unlock
	rm -f $_update

	$AI && return

	set -m
	(
	while :; do
		lock
		if [[ -e $_update && "$(dmesgtail)" != "$(<$_update)" ]]; then
			dmesgtail >$_update
			rm -f /tmp/cppid
			kill -TERM 2>/dev/null $$ || exit 1
		fi
		unlock
		sleep .5
	done
	) |&
	echo $! > /tmp/cppid
	set +m
	retrap
}


log_answers() {
	if [[ -n $1 && -n $2 ]]; then
		print -r -- "${1%%'?'*} = $2" >>/tmp/i/$MODE.resp
	fi
}

get_responsefile() {
	local _rf _if _lf _path _aifile
	export AI_HOSTNAME= AI_MAC= AI_MODE= AI_SERVER=

	[[ -f /auto_upgrade.conf ]] && _rf=/auto_upgrade.conf AI_MODE=upgrade
	[[ -f /auto_install.conf ]] && _rf=/auto_install.conf AI_MODE=install
	[[ -f $_rf ]] && cp $_rf /tmp/ai/ai.$AI_MODE.conf && return

	for _if in ''; do
		[[ -x /sbin/dhcpleased ]] || break

		set -- $(get_ifs netboot)
		(($# == 0)) && set -- $(get_ifs)
		(($# == 1)) && _if=$1

		while (($# > 1)); do
			ask_which "network interface" \
				"should be used for the initial DHCP request" \
				"$*"
			isin "$resp" $* && _if=$resp && break
		done

		[[ -n $_if ]] && ifconfig $_if inet autoconf || break
		_lf=/var/db/dhcpleased/$_if

		if ! wait_for_dhcp_info $_if 30; then
			echo "No dhcp address on interface $_if in 30 seconds."
			continue
		fi

		_aifile=$(lease_value $_lf filename)
		[[ $_aifile == ?(*/)auto_@(install|upgrade) ]] || _aifile=
		_path=${_aifile%auto_@(install|upgrade)}
		AI_MODE=${_aifile##*?(/)auto_}

		AI_SERVER=$(lease_value $_lf next-server)

		AI_HOSTNAME=$(lease_value $_lf host-name)
		hostname "$AI_HOSTNAME"
	done

	if [[ -n $AI_SERVER && -n $AI_MODE ]]; then
		AI_MAC=$(ifconfig $_if | sed 's/.*lladdr \(.*\)/\1/p;d')
		for _rf in {$AI_MAC-,${AI_HOSTNAME:+$AI_HOSTNAME-,}}$AI_MODE; do
			_url="http://$AI_SERVER/$_path$_rf.conf?path=$HTTP_SETDIR"
			echo "Fetching $_url"
			if unpriv ftp -Vo - "$_url" \
				>"/tmp/ai/ai.$AI_MODE.conf" 2>/dev/null; then
				ifconfig $_if inet -autoconf delete down \
				    2>/dev/null
				rm /var/db/dhcpleased/$_if
				return 0
			fi
		done
	else
		[[ -z $AI_SERVER ]] && echo "Could not determine auto server."
		[[ -z $AI_MODE ]] && echo "Could not determine auto mode."
	fi

	while :; do
		ask "Response file location?" \
			"${AI_SERVER:+http://$AI_SERVER/install.conf}"
		[[ -n $resp ]] && _rf=$resp && break
	done

	AI_MODE=$(echo "$_rf" | sed -En 's/^.*(install|upgrade).conf$/\1/p')
	while [[ -z $AI_MODE ]]; do
		ask "(I)nstall or (U)pgrade?"
		[[ $resp == [iI]* ]] && AI_MODE=install
		[[ $resp == [uU]* ]] && AI_MODE=upgrade
	done

	echo "Fetching $_rf"
	[[ -f $_rf ]] && _rf="file://$_rf"
	if unpriv ftp -Vo - "$_rf" >"/tmp/ai/ai.$AI_MODE.conf" 2>/dev/null; then
		ifconfig $_if inet -autoconf delete down 2>/dev/null
		return 0
	fi
	return 1
}

_autorespond() {
	typeset -l _q=$1 _key
	local _def=$2 _l _val

	[[ -f $AI_RESPFILE && -n $_q ]] || return

	mv /tmp/ai/ai.conf /tmp/ai/ai.conf.tmp
	while IFS=' 	' read -r _l; do
		[[ $_l == [!#=]*=?* ]] || continue
		_key=${_l%%*([[:blank:]])=*}
		_val=${_l##*([!=])=*([[:blank:]])}
		[[ $_q == @(|*[[:blank:]])"$_key"@([[:blank:]?]*|) ]] &&
			resp=$_val && cat && return
		print -r " $_l"
	done </tmp/ai/ai.conf.tmp >/tmp/ai/ai.conf
	[[ -n $_def ]] && resp=$_def && return
	err_exit "\nQuestion has no answer in response file: \"$_q\""
}

_ask() {
	local _q=$1 _def=$2 _int _redo=0 _pid

	lock; dmesgtail >/tmp/i/update; unlock
	echo -n "${_q:+$_q }${_def:+[$_def] }"
	_autorespond "$_q" "$_def" && echo "$resp" && return
	trap "_int=1" INT
	trap "_redo=1" TERM
	read resp
	lock; rm /tmp/i/update; unlock
	if ((_redo)); then
		stty raw
		stty -raw
	else
		case $resp in
		!)	echo "Type 'exit' to return to install."
			ksh
			_redo=1
			;;
		!*)	eval "${resp#?}"
			_redo=1
			;;
		esac
	fi
	retrap
	((_int)) && kill -INT $$
	: ${resp:=$_def}
	return $_redo
}

ask() {

	while ! _ask "$1" "$2"; do :; done
	log_answers "$1" "$resp"
}

ask_yn() {
	local _q=$1 _a=${2:-no}
	typeset -l _resp

	while :; do
		ask "$_q" "$_a"
		_resp=$resp
		case $_resp in
		y|yes)	resp=y; return 0;;
		n|no)	resp=n; return 1;;
		esac
		echo "'$resp' is not a valid choice."
		$AI && exit 1
	done
}

ask_which() {
	local _name=$1 _query=$2 _list=$3 _def=$4 _dynlist _dyndef _key _q
	_key=$(echo "$_name" | sed 's/[^[:alnum:]]/_/g')

	while :; do
		eval "_dynlist=\"$_list\""
		eval "_dyndef=\"$_def\""

		set -o noglob
		set -- $_dyndef; _dyndef="$1"
		set -- $_dynlist; _dynlist="$*"
		set +o noglob
		(($# < 1)) && resp=done && return
		: ${_dyndef:=$1}

		echo "Available ${_name}s are: $_dynlist."
		_q="Which $_name $_query?"
		echo -n "$_q (or 'done') ${_dyndef:+[$_dyndef] }"
		_autorespond "$_q" "${_dyndef-done}" && echo "$resp" \
			|| _ask || continue
		[[ -z $resp ]] && resp="$_dyndef"

		if isin "$resp" $_dynlist done; then
			log_answers "$_q" "$resp"
			break
		fi
		echo "'$resp' is not a valid choice."
		$AI && [[ -n $AI_RESPFILE ]] && exit 1
	done
}

ask_until() {
	resp=

	while :; do
		ask "$1" "$2"
		[[ -n $resp ]] && break
		echo "A response is required."
		$AI && exit 1
	done
}

ask_pass() {
	stty -echo
	IFS= read -r resp?"$1 "
	stty echo
	echo
}

ask_password() {
	local _q=$1

	if $AI; then
		echo -n "$_q "
		_autorespond "$_q"
		echo '<provided>'
		_password=$resp
		return
	fi

	while :; do
		ask_pass "$_q (will not echo)"
		_password=$resp

		ask_pass "$_q (again)"
		[[ $resp == "$_password" ]] && break

		echo "Passwords do not match, try again."
	done
}

ask_passphrase() {
	local _q=$1

	if $AI; then
		echo -n "$_q "
		_autorespond "$_q"
		echo '<provided>'
		_passphrase=$resp
		return
	fi

	while :; do
		IFS= read -r _passphrase?"$_q (will echo) "

		[[ -n $_passphrase ]] && break

		echo "Empty passphrase, try again."
	done
}


dhcp_request() {
	local _if=$1

	echo "lookup file bind" >>/etc/resolv.conf

	ifconfig $_if group dhcp >/dev/null 2>&1

	if [[ -x /sbin/dhcpleased ]]; then
		ifconfig $_if inet autoconf
		if ! wait_for_dhcp_info $_if 30; then
			echo "No dhcp address on interface $_if in 30 seconds."
		fi

	else
		echo "DHCP leases not available during install."
	fi
}

v4_info() {
	ifconfig $1 inet | sed -n '
		1s/.*flags=.*<\(.*\)>.*/\1/p
		/inet/s/netmask //
		/.inet /s///p'
}

wait_for_dhcp_info() {
	local _if=$1 _secs=$2

	while (( _secs > 0 )); do
		set -- $(v4_info $_if)
		[[ -n $2 ]] && break
		sleep 1
		(( _secs-- ))
	done

	while (( _secs > 0 )); do
		[[ -s /var/db/dhcpleased/$_if ]] && break
		sleep 1
		(( _secs-- ))
	done

	return $(( _secs <= 0 ))
}

hextodec() {
	set -- $(echo ${1#0x} | sed 's/\(..\)/0x\1 /g')
	echo $(($1)).$(($2)).$(($3)).$(($4))
}

add_hostent() {
	local _addr=$1 _name=$2 _delim="."

	[[ -z $_addr || -z $_name ]] && return

	[[ $_addr == *:* ]] && _delim=":"
	sed -i "/^[0-9a-fA-F]*[$_delim].*[ 	]$_name\$/d" \
		/tmp/i/hosts 2>/dev/null

	echo "$_addr $_name" >>/tmp/i/hosts
}

vlan_config() {
	local _if=$1 _hn=/tmp/i/hostname.$1 _hn_vd _vd _vdvi _vdvi_used _vi
	local _sed_vdvi='s/.encap: vnetid ([[:alnum:]]+) parent ([[:alnum:]]+)/\2:\1/p'

	_vdvi=$(ifconfig $_if 2>/dev/null | sed -En "$_sed_vdvi")
	_vd=${_vdvi%%:*}
	_vi=${_vdvi##*:}

	if [[ $_vi == @(|none) ]]; then
		((${_if##vlan} == 0)) && _vi=none || _vi=${_if##vlan}
	fi

	if [[ $_vd == @(|none) ]]; then
		_vd=$(get_ifs | sed '/^vlan/d' | sed q)
	fi

	ask "Which interface:tag should $_if be on?" "$_vd:$_vi"
	_vd=${resp%%:*}
	_vi=${resp##*:}

	if ! isin "$_vd" $(get_ifs | sed '/^vlan/d'); then
		echo "Invalid parent interface choice '$_vd'."
		return 1
	fi

	_vdvi_used=$(ifconfig vlan 2>/dev/null | sed -En "$_sed_vdvi")

	for _vdvi in $_vdvi_used; do
		if [[ $_vdvi == $_vd:* && ${_vdvi##*:} == $_vi ]]; then
			echo "vlan tag '$_vi' already used on parent '$_vd'"
			return 1
		fi
	done

	if [[ $_vi == none ]]; then
		_vi="-vnetid"
	elif (($_vi > 0 && $_vi < 4096)); then
		_vi="vnetid $_vi"
	else
		echo "Invalid vlan tag '$_vi'."
		return 1
	fi

	_hn_vd=/tmp/i/hostname.$_vd
	grep -qs "^up" $_hn_vd || echo up >>$_hn_vd
	echo "$_vi parent $_vd" >>$_hn
	chmod 640 $_hn_vd $_hn

	ifconfig $_vd up
	ifconfig $_if destroy >/dev/null 2>&1
	ifconfig $_if create >/dev/null 2>&1
	ifconfig $_if $_vi parent $_vd
}

v4_config() {
	local _if=$1 _name=$2 _hn=$3 _addr _mask _newaddr

	set -- $(v4_info $_if)
	if [[ -n $2 ]] && ! isin $_if $(get_ifs dhcp); then
		_addr=$2;
		_mask=$(hextodec $3)
	fi

	ifconfig $_if -inet
	ifconfig $_if -group dhcp >/dev/null 2>&1

	while :; do
		ask_until "IPv4 address for $_if? (or 'autoconf' or 'none')" \
			  "${_addr:-autoconf}"
		case $resp in
		none)	return
			;;
		a|autoconf|dhcp)
			dhcp_request $_if
			echo "inet autoconf" >>$_hn
			return
			;;
		esac

		_newaddr=$resp

		if [[ $_newaddr == */* ]]; then
			ifconfig $_if $_newaddr up
		else
			ask_until "Netmask for $_if?" "${_mask:-255.255.255.0}"
			ifconfig $_if $_newaddr netmask $resp
		fi

		set -- $(v4_info $_if)
		if [[ -n $2 ]]; then
			echo "inet $2 $3" >>$_hn
			add_hostent "$2" "$_name"
			return
		fi

		$AI && exit 1
	done
}

v6_info() {
	ifconfig $1 inet6 | sed -n '
		1s/.*flags=.*<\(.*\)>.*/\1/p
		/scopeid/d
		/inet6/s/prefixlen //
		/.inet6 /s///p'
}

v6_defroute() {
	local _if _v6ifs _prompt _resp _routers _dr

	for _if in $(get_ifs); do
		set -- $(v6_info $_if)
		[[ -z $2 || $1 == *AUTOCONF6* ]] || _v6ifs="$_v6ifs $_if"
	done
	[[ -n $_v6ifs ]] || return

	_routers=$(route -n show -inet6 |
		sed -En 's/^default[[:space:]]+([^[:space:]]+).*/\1 /p')

	for _if in $_v6ifs; do
		_resp=$(ping6 -n -c 2 ff02::2%$_if 2>/dev/null |
			sed -En '/^[0-9]+ bytes from /{s///;s/: .*$//p;}')
		for _dr in $_resp; do
			_routers=$(addel $_dr $_routers)
		done
	done

	[[ -n $_routers ]] && _routers=$(bsort $_routers)
	_prompt="IPv6 default router?"

	if $AI; then
		_autorespond "$_prompt (IPv6 address or 'none')" none &&
			echo "$_prompt $resp"
		[[ $resp != none ]] &&
			route -n add -inet6 -host default $resp &&
			echo $resp >>/tmp/i/mygate
	else
		set -A _routers -- $_routers
		while :; do
			ask_until "$_prompt (IPv6 address, list#, 'none' or '?')"
			case $resp in
			none)	return
				;;
			'?')	for _dr in ${_routers[@]}; do
					echo $_dr
				done | cat -n
				continue
				;;
			+([0-9]))
				if ((resp < 1 || resp > ${#_routers[@]})); then
					echo "$resp is not a valid choice."
					continue
				fi
				resp=${_routers[$((--resp))]}
				;;
			esac

			route -n -q delete -inet6 -host default "$resp"
			if route -n add -inet6 -host default "$resp"; then
				echo "$resp" >>/tmp/i/mygate
				break
			fi
		done
	fi
}

v6_config() {
	local _if=$1 _name=$2 _hn=$3 _addr _newaddr _prefixlen

	ifconfig lo0 inet6 >/dev/null 2>&1 || return

	set -- $(v6_info $_if)
	if [[ $1 == *AUTOCONF6* ]]; then
		_addr=autoconf
	elif [[ -n $2 ]]; then
		_addr=$2
		_prefixlen=$3
	fi

	ifconfig $_if -inet6

	while :; do
		ask_until "IPv6 address for $_if? (or 'autoconf' or 'none')" \
			  "${_addr:-autoconf}"
		case $resp in
		none)	return
			;;
		a|autoconf)
			ifconfig $_if inet6 autoconf up
			echo "inet6 autoconf" >>$_hn
			return
			;;
		esac

		_newaddr=$resp
		if [[ $_newaddr == */* ]]; then
			ifconfig $_if inet6 $_newaddr up
		else
			ask_until "IPv6 prefix length for $_if?" \
				  "${_prefixlen:-64}"
			ifconfig $_if inet6 $_newaddr/$resp up
		fi

		set -- $(v6_info $_if)
		if [[ -n $2 ]]; then
			echo "inet6 $2 $3" >>$_hn
			add_hostent "$2" "$_name"
			return
		fi

		$AI && exit 1
	done
}

ieee80211_scan() {
	[[ -f $WLANLIST ]] ||
		ifconfig $1 scan |
			sed -n 's/^[[:space:]]*nwid \(.*\) chan [0-9]* bssid \([[:xdigit:]:]*\).*/\1 (\2)/p' >$WLANLIST
	cat $WLANLIST
}

ieee80211_config() {
	local _if=$1 _hn=$2 _prompt _nwid _haswep=0 _haswpa=0 _err

	ifconfig $_if -nwid
	ifconfig $_if -nwkey 2>/dev/null && _haswep=1
	ifconfig $_if -wpa 2>/dev/null && _haswpa=1

	rm -f $WLANLIST

	while [[ -z $_nwid ]]; do
		ask_until "Access point? (ESSID, 'any', list# or '?')" "any"
		case "$resp" in
		+([0-9]))
			_nwid=$(ieee80211_scan $_if |
			    sed -n ${resp}'{s/ ([[:xdigit:]:]*)$//p;q;}')
			[[ -z $_nwid ]] && echo "There is no line $resp."
			[[ $_nwid = \"*\" ]] && _nwid=${_nwid#\"} _nwid=${_nwid%\"}
			;;
		\?)	ieee80211_scan $_if | cat -n | more -c
			;;
		*)	_nwid=$resp
			;;
		esac
	done

	if [[ $_nwid != any ]]; then

		_prompt="Security protocol? (O)pen"
		((_haswep == 1)) && _prompt="$_prompt, (W)EP"
		((_haswpa == 1)) && _prompt="$_prompt, WPA-(P)SK"
		while :; do
			ask_until "$_prompt" "O"
			case "${_haswep}${_haswpa}-${resp}" in
			??-[Oo]) # No further questions
				ifconfig $_if join "$_nwid"
				quote join "$_nwid" >>$_hn
				break
				;;
			1?-[Ww])	ask_passphrase "WEP key?"
				if _err=$(ifconfig $_if join "$_nwid" nwkey "$_passphrase" 2>&1) &&
					[[ -z $_err ]]; then
					quote join "$_nwid" nwkey "$_passphrase" >>$_hn
					break
				fi
				echo "$_err"
				;;
			?1-[Pp])	ask_passphrase "WPA passphrase?"
				if ifconfig $_if join "$_nwid" wpakey "$_passphrase"; then
					quote join "$_nwid" wpakey "$_passphrase" >>$_hn
					break
				fi
				;;
			*)	echo "'$resp' is not a valid choice."
				;;
			esac
		done
	fi
}

configure_ifs() {
	local _first _hn _if _ifs _lladdr _name _p _q _vi _vn
	resp=

	ifconfig lo0 inet 127.0.0.1/8

	rm -f /tmp/i/mygate

	while :; do
		set -sA _ifs -- $(get_ifs)

                ((${#_ifs[*]} == 0)) && break

		_vi=
		for _if in "${_ifs[@]}"; do
			[[ $_if = vlan+([[:digit:]]) ]] && _vi=${_if#vlan}
		done
		[[ -n $_vi ]] && ((_vi++))
		[[ -n ${_ifs[*]} ]] && _vn="vlan${_vi:-0}"

		echo "Available network interfaces are: ${_ifs[*]} $_vn."
		if [[ $resp == '?' ]]; then
			for _if in "${_ifs[@]}"; do
				_lladdr=$(if_name_to_lladdr $_if)
				[[ -n $_lladdr ]] && echo "    $_if: lladdr $_lladdr"
			done
		fi

		_q="Network interface to configure?"
		ask_until "$_q (name, lladdr, '?', or 'done')" \
		    ${_p:-$( (get_ifs netboot; get_ifs) | sed q )}

		[[ $resp == done ]] && break
		[[ $resp == '?'  ]] && continue

		if ! isin "$resp" $(get_ifs_and_lladdrs) $_vn done; then
			echo "'$resp' is not a valid choice."
			$AI && [[ -n $AI_RESPFILE ]] && exit 1
			continue
		fi

		_if=$resp
		_hn=/tmp/i/hostname.$_if
		rm -f $_hn

		if [[ $_if == ??:??:??:??:??:?? ]]; then
			_lladdr=$_if
			_if=$(ifconfig -M $_lladdr)
			[[ -z $_if ]] && continue # should not be possible
			rm -f /tmp/i/hostname.$_if
		else
			_lladdr=$(if_name_to_lladdr $_if)
			[[ -n $_lladdr ]] && rm -f /tmp/i/hostname.$_lladdr
		fi

		if [[ $_if == vlan+([0-9]) ]]; then
			vlan_config $_if || continue
		fi

		ifconfig $_if 2>/dev/null | grep -q "^[[:space:]]*ieee80211:" &&
			ieee80211_config $_if $_hn

		resp=$(hostname -s)
		[[ -n $_first && $_first != $_if ]] &&
			ask "Symbolic (host) name for $_if?" "$resp"
		_name=$resp

		v4_config $_if $_name $_hn
		v6_config $_if $_name $_hn

		if [[ -f $_hn ]]; then
			chmod 640 $_hn
			: ${_first:=$_if}
		fi

		NIFS=$(ls -1 /tmp/i/hostname.* 2>/dev/null | grep -c ^)
		_p=done
	done
}

v4_defroute() {
	local _dr _dr_if

	grep -q '^inet ' /tmp/i/hostname.* 2>/dev/null || return

	set -- $(route -n show -inet |
		sed -En 's/^default +([0-9.]+) .* ([a-z0-9]+) *$/\1 \2/p')
	[[ -n $1 ]] && _dr=$1 _dr_if=$2

	[[ -n $_dr ]] && isin "$_dr_if" $(get_ifs dhcp) && return

	while :; do
		ask_until "Default IPv4 route? (IPv4 address or 'none')" "$_dr"
		[[ $resp == none ]] && break
		route delete -inet default >/dev/null 2>&1
		if route -n add -inet -host default "$resp"; then
			echo "$resp" >>/tmp/i/mygate
			break
		else
			route -n add -inet -host default $_dr >/dev/null 2>&1
		fi
	done
}

get_fqdn() {
	local _dn

	_dn=$(hostname)
	_dn=${_dn#$(hostname -s)}
	_dn=${_dn#.}

	echo "${_dn:=my.domain}"
}



sane_install() {
	local _q=$1 _s

	for _s in $SANESETS; do
		isin "$_s" $DEFAULTSETS || continue
		[[ -n $_q ]] && return 1
		if ! ask_yn "Are you *SURE* your $MODE is complete without '$_s'?"; then
			$AI && exit 1 || return 1
		fi
	done
}

select_sets() {
	local _avail=$1 _selected=$2 _f _action _col=$COLUMNS
	local _bsd_rd _no_sets=true

	if [[ $MODE == upgrade ]]; then
		for _f in $_avail; do
			[[ $_f != bsd* ]] && _no_sets=false
			[[ $_f == bsd.rd* ]] && _bsd_rd=$_f
		done
		$_no_sets && UPGRADE_BSDRD=true _avail=$_bsd_rd _selected=$_bsd_rd
	fi

	let COLUMNS=_col-8

	cat <<'__EOT'

Select sets by entering a set name, a file name pattern or 'all'. De-select
sets by prepending a '-', e.g.: '-game*'. Selected sets are labelled '[X]'.
__EOT
	while :; do
		for _f in $_avail; do
			isin "$_f" $_selected && echo "[X] $_f" || echo "[ ] $_f"
		done | show_cols | sed 's/^/    /'
		ask "Set name(s)? (or 'abort' or 'done')" done

		set -o noglob
		for resp in $resp; do
			case $resp in
			abort)	_selected=; break 2;;
			done)	break 2;;
			-*)	_action=rmel;;
			*)	_action=addel;;
			esac
			resp=${resp#[+-]}
			[[ $resp == all ]] && resp=*

			for _f in $_avail; do
				[[ $_f == $resp ]] &&
					_selected=$($_action $_f $_selected)
			done
		done
	done

	set +o noglob
	COLUMNS=$_col

	resp=$_selected
}

do_as() {
	(( $# >= 2 )) || return

	local _file _rc _user=$1
	shift

	if [[ $1 == -f ]]; then
		_file=$2
		shift 2
	fi

	if [[ -n $_file ]]; then
		>$_file
		chown "$_user" "$_file"
	fi

	doas -u "$_user" "$@"
	_rc=$?

	while doas -u "$_user" kill -9 -1 2>/dev/null; do
		echo "Processes still running for user $_user after: $@"
		sleep 1
	done

	[[ -n $_file ]] && chown root "$_file"

	return $_rc
}

unpriv() {
	do_as _sndio "$@"
}

unpriv2() {
	do_as _file "$@"
}

prefetcharea_fs_list() {
	local _fs_list

	_fs_list=$( (
		for fs in /mnt/{tmp,home,usr{/local,}}; do
			df -k $fs 2>/dev/null | grep " $fs\$"
		done
		df -k
	) | (
		while read a a a a m m; do
			[[ $m == /mnt/@(tmp|home|usr/@(src,obj,xobj))@(|/*) ]] &&
				((a > 524288)) && echo $m && continue
			[[ $m == /mnt@(|/*) ]] &&
				((a > 524288 * 4)) && echo $m
		done
	) | (
		while read fs; do
			isin "$fs" $list || list="$list${list:+ }$fs"
		done
		echo $list
	) )

	[[ -n $_fs_list ]] && echo $_fs_list || return 1
}

install_files() {
	local _src=$1 _files=$2 _f _sets _get_sets _n _col=$COLUMNS _tmpfs \
		_tmpfs_list _tmpsrc _cfile=/tmp/SHA256 _fsrc _unver _t _issue
	local _srclocal=false _unpriv=unpriv

	[[ $_src == file://* ]] && _srclocal=true _unpriv=

	for _f in $ALLSETS; do
		isin "$_f" $_files || continue
		_sets=$(addel $_f $_sets)
		isin "$_f" $DEFAULTSETS "site$VERSION-$(hostname -s).tgz" &&
			_get_sets=$(addel $_f $_get_sets)
	done

	if [[ -z $_sets ]]; then
		echo -n "Looked at $_src "
		echo "and found no $OBSD sets.  The set names looked for were:"

		let COLUMNS=_col-8
		for _n in $ALLSETS; do echo $_n; done | show_cols | sed 's/^/    /'
		COLUMNS=$_col

		$AI && exit 1
		echo
		return
	fi

	isin "INSTALL.$ARCH" $_files ||
		ask_yn "INSTALL.$ARCH not found. Use sets found here anyway?" ||
		return

	select_sets "$_sets" "$_get_sets"

	[[ -n $resp ]] || return
	_get_sets=$resp

	_get_sets=$(for s in $ALLSETS; do isin "$s" $_get_sets && echo $s; done;
	    isin "BUILDINFO" $_files && echo "BUILDINFO")

	_unver=$_get_sets

	for _issue in ''; do
		! isin SHA256.sig $_files &&
			_issue="Directory does not contain SHA256.sig" && break

		if ! $_srclocal; then
			! _tmpfs_list=$(prefetcharea_fs_list) &&
				_issue="Cannot determine prefetch area" && break

			for _tmpfs in $_tmpfs_list; do
				for _tmpsrc in $_tmpfs/sets.+([0-9]).+([0-9]); do
					[[ -d $_tmpsrc ]] && rm -r $_tmpsrc
				done

				if _tmpsrc=$(tmpdir "$_tmpfs/sets"); then
					(
					>$_tmpsrc/t &&
					$_unpriv cat $_tmpsrc/t
					) >/dev/null 2>&1 && break ||
						rm -r $_tmpsrc
				fi
			done

			[[ ! -d $_tmpsrc ]] &&
				_issue="Cannot create prefetch area" && break
		fi

		rm -f $_cfile $_cfile.sig

		_t=Get/Verify
		$_srclocal && _t='Verifying '

		! $_unpriv ftp -D "$_t" -Vmo - "$_src/SHA256.sig" >"$_cfile.sig" &&
			_issue="Cannot fetch SHA256.sig" && break

		$UPGRADE_BSDRD &&
			PUB_KEY=/mnt/etc/signify/openbsd-$((VERSION + 1))-base.pub

		! unpriv -f "$_cfile" \
			signify -Vep $PUB_KEY -x "$_cfile.sig" -m "$_cfile" &&
			_issue="Signature check of SHA256.sig failed" && break

		for _f in $_get_sets; do
			reset_watchdog

			rm -f /tmp/h /tmp/fail

			( $_unpriv ftp -D "$_t" -Vmo - "$_src/$_f" || >/tmp/fail ) |
			( $_srclocal && unpriv2 sha256 >/tmp/h ||
				unpriv2 -f /tmp/h sha256 -ph /tmp/h >"$_tmpsrc/$_f" )

			if [[ -f /tmp/fail ]]; then
				rm -f "$_tmpsrc/$_f"
				if ! ask_yn "Fetching of $_f failed. Continue anyway?"; then
					[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc"
					$AI && exit 1
					return
				fi
				_unver=$(rmel $_f $_unver)
				_get_sets=$(rmel $_f $_get_sets)
				continue
			fi

			if fgrep -qx "SHA256 ($_f) = $(</tmp/h)" "$_cfile"; then
				_unver=$(rmel $_f $_unver)
			else
				if ! ask_yn "Checksum test for $_f failed. Continue anyway?"; then
					[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc"
					$AI && exit 1
					return
				fi
			fi
		done
	done

	[[ -n $_unver ]] && : ${_issue:="Unverified sets:" ${_unver% }}
	if [[ -n $_issue ]] &&
		! ask_yn "$_issue. Continue without verification?"; then
		[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc"
		$AI && exit 1
		return
	fi

	if [[ $MODE == upgrade ]]; then
		if isin base$VERSION.tgz $_get_sets; then
			rm -rf /mnt/usr/share/relink/*
			rm -rf /mnt/usr/lib/libLLVM.so.[0-7].0
			rm -rf /mnt/usr/libdata/perl5
		fi
		if isin comp$VERSION.tgz $_get_sets; then
			rm -rf /mnt/usr/lib/{gcc-lib,clang}
			rm -rf /mnt/usr/bin/{gcc,g++}
			rm -rf /mnt/usr/include/g++
			rm -rf /mnt/usr/include/c++/v1
		fi

		chown -R _fc-cache:_fc-cache /mnt/var/cache/fontconfig >/dev/null 2>&1

		rm -rf /mnt/var/syspatch/*
	fi

	for _f in $_get_sets; do
		reset_watchdog
		_fsrc="$_src/$_f"

		[[ -f $_tmpsrc/$_f ]] && _fsrc="file://$_tmpsrc/$_f"

		case $_fsrc in
		*.tgz)	$_unpriv ftp -D Installing -Vmo - "$_fsrc" |
				tar -zxphf - -C /mnt &&
			if [[ $_f == ?(x)base*.tgz && $MODE == install ]]; then
				ftp -D Extracting -Vmo - \
				file:///mnt/var/sysmerge/${_f%%base*}etc.tgz |
				tar -zxphf - -C /mnt
			fi
			;;
		*BUILDINFO) $_unpriv ftp -D Installing -Vmo - "$_fsrc" \
			    > "/mnt/var/db/installed.$_f"
			;;
		*)	# Make a backup of the existing ramdisk kernel in the
			$UPGRADE_BSDRD && [[ $_f == bsd.rd* ]] &&
				cp /mnt/$_f /mnt/$_f.old.$VERSION
			$_unpriv ftp -D Installing -Vmo - "$_fsrc" >"/mnt/$_f"
			;;
		esac
		if (($?)); then
			if ! ask_yn "Installation of $_f failed. Continue anyway?"; then
				[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc"
				$AI && exit 1
				return
			fi
		else
			DEFAULTSETS=$(rmel $_f $DEFAULTSETS)
			$UPGRADE_BSDRD && DEFAULTSETS=
		fi
		[[ -d $_tmpsrc ]] && rm -f "$_tmpsrc/$_f"
	done
	[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc" || true

	if [[ -f $_cfile ]]; then
		cp $_cfile /mnt/var/db/installed.SHA256
	elif $_srclocal && [[ -f ${_src#file://}/SHA256 ]]; then
		cp ${_src#file://}/SHA256 /mnt/var/db/installed.SHA256
	fi

	reset_watchdog
}

install_http() {
	local _d _f _flist _file_list _prompt _tls _http_proto _url_base
	local _idx=/tmp/i/index.txt _sha=/tmp/i/SHA256 _sig=/tmp/i/SHA256.sig
	local _iu_url _iu_srv _iu_dir _mirror_url _mirror_srv _mirror_dir
	local _ftp_stdout=/tmp/i/ftpstdout _rurl_base


	ask "HTTP proxy URL? (e.g. 'http://proxy:8080', or 'none')" \
		"${http_proxy:-none}"
	unset http_proxy
	[[ $resp == none ]] || export http_proxy=$resp

	if [[ -s $HTTP_LIST ]]; then
		_prompt="HTTP Server? (hostname, list#, 'done' or '?')"
	else
		echo "(Unable to get list from openbsd.org, but that is OK)"
		_prompt="HTTP Server? (hostname or 'done')"
	fi

	if [[ $MODE == upgrade ]] &&
		_iu_url=$(stripcom /mnt/etc/installurl); then
		_iu_srv=${_iu_url#*://}
		_iu_srv=${_iu_srv%%/*}
		_iu_dir=${_iu_url##*$_iu_srv*(/)}
		[[ -n $_iu_srv ]] && HTTP_SERVER=$_iu_srv
	fi

	while :; do
		ask_until "$_prompt" "$HTTP_SERVER"
		case $resp in
		done)	return
			;;
		"?")	[[ -s $HTTP_LIST ]] || continue
			cat -n < $HTTP_LIST | more -c
			;;
		+([0-9]))
			[[ -s $HTTP_LIST ]] || continue
			set -- $(sed -n "${resp}p" $HTTP_LIST)
			if (($# < 1)); then
				echo "There is no line $resp."
				continue
			fi
			HTTP_SERVER=${1%%/*}
			;;
		?(http?(s)://)+([A-Za-z0-9:.\[\]%_-]))
			case $resp in
			https://*)	_tls=force _http_proto=https;;
			http://*)	_tls=no    _http_proto=http;;
			*)		_tls=try   _http_proto=$HTTP_PROTO;;
			esac
			if ! $FTP_TLS && [[ $_tls == force ]]; then
				echo "https not supported on this platform."
				$AI && exit 1 || continue
			fi
			HTTP_SERVER=${resp#*://}
			break
			;;
		*)	echo "'$resp' is not a valid hostname."
			;;
		esac
	done

	set -- $(grep -i "^$HTTP_SERVER" $HTTP_LIST 2>/dev/null | sed '$!d')
	_mirror_url=${1%%*(/)}
	_mirror_srv=${_mirror_url%%/*}
	_mirror_dir=${_mirror_url##*$_mirror_srv*(/)}

	if [[ -n $_mirror_url ]]; then
		_d=$_mirror_dir/$HTTP_SETDIR

		(($# > 1)) && INSTALL_MIRROR=$_mirror_url
	elif [[ -n $_iu_url ]]; then
		_d=$_iu_dir/$HTTP_SETDIR
	else
		_d=pub/OpenBSD/$HTTP_SETDIR
	fi

	ask_until "Server directory?" "$_d"
	HTTP_DIR=${resp##+(/)}
	_url_base="$_http_proto://$HTTP_SERVER/$HTTP_DIR"

	rm -f $_idx $_sha $_sig $_ftp_stdout
	if ! unpriv -f $_sig \
		ftp -w 15 -vMo $_sig "$_url_base/SHA256.sig" \
			>$_ftp_stdout 2>/dev/null; then
		case $_tls in
		force)	$AI && exit 1 || return
			;;
		try)	echo "Unable to connect using HTTPS; using HTTP instead."
			_http_proto=http
			_url_base="http://$HTTP_SERVER/$HTTP_DIR"
			unpriv -f $_sig ftp -vMo $_sig "$_url_base/SHA256.sig" \
				>$_ftp_stdout 2>/dev/null
			;;
		esac
	fi

	_rurl_base=$(sed -n 's/^Requesting //p' $_ftp_stdout | sed '$!d')
	_rurl_base=${_rurl_base%/SHA256.sig*}

	if unpriv -f $_sha \
		signify -Vep $PUB_KEY -x $_sig -m $_sha >/dev/null 2>&1; then
		_file_list="$(sed -n 's/^SHA256 (\(.*\)).*$/\1/p' $_sha)"
		_file_list="SHA256.sig $_file_list"
	else
		echo "Unable to get a verified list of distribution sets."
		if [[ ${_rurl_base%/$HTTP_SETDIR} == "$_http_proto://$INSTALL_MIRROR" ]]; then
			$AI && exit 1 || return
		fi
	fi

	if unpriv -f $_idx \
		ftp -VMo $_idx "$_rurl_base/index.txt" 2>/dev/null; then
		_flist=$(sed -En 's/^.* ([a-zA-Z][a-zA-Z0-9._-]+)$/\1/p' $_idx)
		for _f in $_flist; do
			! isin "$_f" $_file_list && _file_list="$_file_list $_f"
		done
	fi
	rm -f $_idx $_sha $_sig $_ftp_stdout

	install_files "$_rurl_base" "$_file_list"

	if [[ -n $INSTALL_MIRROR ]]; then
		INSTALL_URL=$_http_proto://$INSTALL_MIRROR
	else
		INSTALL_URL=${_url_base%/$ARCH}
		INSTALL_URL=${INSTALL_URL%@(/$VNAME|/snapshots)}
	fi
}

install_mounted_fs() {
	local _dir

	while :; do
		ask_until "Pathname to the sets? (or 'done')" "$SETDIR"
		[[ $resp == done ]] && return
		[[ -d /mnt2/$resp ]] && { _dir=/mnt2/$resp; break; }
		[[ -d /mnt/$resp ]] && { _dir=/mnt/$resp; break; }
		[[ -d /$resp ]] && { _dir=/$resp; break; }
		echo "The directory '$resp' does not exist."
		$AI && exit 1
	done

	install_files "file://$_dir" "$(ls $_dir/)"
}

install_cdrom() {
	local _drive=$1

	make_dev $_drive && mount_mnt2 $_drive || return

	install_mounted_fs
}

install_disk() {
	local _ismounted=yes

	[[ $MODE == install ]] && _ismounted=no

	if ! ask_yn "Is the disk partition already mounted?" $_ismounted; then
		ask_which "disk" "contains the $MODE media" \
			'$(bsort $(get_dkdevs))' \
			'$(get_dkdevs_uninitialized)'
		[[ $resp == done ]] && return 1

		make_dev $resp && mount_mnt2 $resp || return
	fi

	install_mounted_fs
}

install_nfs() {
	local _tcp

	ask_until "Server IP address or hostname?" "$NFS_ADDR"
	NFS_ADDR=$resp

	ask_until "Filesystem on server to mount?" "$NFS_PATH"
	NFS_PATH=$resp

	ask_yn "Use TCP transport? (requires TCP-capable NFS server)" && _tcp=-T

	mount_nfs $_tcp -o ro -R 5 $NFS_ADDR:$NFS_PATH /mnt2 || return

	install_mounted_fs
}

mount_mnt2() {
	local _dev=$1 _opts _file=/tmp/i/parts.$1 _parts

	disklabel $_dev 2>/dev/null |
		sed -En "/swap|unused/d;/^  [${PARTITIONS}]: /p" >$_file
	_parts=$(sed 's/^  \(.\): .*/\1/' $_file)
	set -- $_parts
	(($# == 0)) && { echo "No filesystems found on $_dev."; return 1; }

	if isin "c" $_parts; then
		resp=c
	elif (($# == 1)); then
		resp=$1
	else
		cat $_file
		ask_which "$_dev partition" "has the $MODE sets" "$_parts"
		[[ $resp == done ]] && return 1
	fi

	grep -q "^  $resp: .*MSDOS" $_file && _opts="-s"
	mount -o ro,$_opts /dev/$_dev$resp /mnt2
}



set_term() {
	local _layouts
	export TERM=${TERM:-${MDTERM:-vt220}}

	if [[ -n $CONSOLE ]]; then
		ask "Terminal type?" "$TERM"
		TERM=$resp
	else
		[[ -x /sbin/kbd ]] || return
		_layouts=$(bsort $(kbd -l | egrep -v "^(user|tables|encoding)"))
		make_dev $(scan_dmesg '/^wskbd[0-9]* /s/ .*//p')
		while :; do
			ask "Choose your keyboard layout ('?' or 'L' for list)" default
			case $resp in
			[lL\?])		echo "Available layouts: $_layouts"
					;;
			default)	break
					;;
			*)		if kbd -q "$resp"; then
						echo $resp >/tmp/i/kbdtype
						break
					fi
					;;
			esac
		done
	fi
}

donetconfig() {
	local _dn _ns _f1 _f2 _f3 _autoconf_ns=false

	configure_ifs
	v4_defroute
	v6_defroute

	if [[ -f /etc/resolv.conf ]]; then
		while read -r -- _f1 _f2 _f3; do
			[[ $_f1 == nameserver ]] && _ns="${_ns:+$_ns }$_f2"
			[[ $_f3 == '# resolvd: '* ]] && _autoconf_ns=true
			[[ $_f1 == @(domain|search) ]] && _dn=$_f2
		done </etc/resolv.conf
	fi

	resp="${_dn:-$(get_fqdn)}"
	if ifconfig dhcp >/dev/null 2>&1 && [[ $NIFS == 1 && -z $_dn ]]; then
		set -- $(get_ifs dhcp)
		set -- $(lease_value /var/db/dhcpleased/$1 domain-name)
		[[ -n $1 ]] && resp=$1
		echo "Using DNS domainname $resp"
	else
		ask "DNS domain name? (e.g. 'example.com')" "$resp"
	fi
	hostname "$(hostname -s).$resp"

	if $_autoconf_ns && [[ -n $_ns ]]; then
		echo "Using DNS nameservers at $_ns"
		return
	fi

	resp="${_ns:-none}"
	if ifconfig dhcp >/dev/null 2>&1 && [[ $NIFS == 1 && -n $_ns ]]; then
		echo "Using DNS nameservers at $resp"
	else
		ask "DNS nameservers? (IP address list or 'none')" "$resp"
	fi

	if [[ $resp != none ]]; then
		echo "lookup file bind" >/tmp/resolv.conf
		for _ns in $resp; do
			echo "nameserver $_ns" >>/tmp/resolv.conf
		done
		cp /tmp/resolv.conf /etc/resolv.conf
	fi
}

questions() {
	local _d _cdef=no

	ask_yn "Start sshd(8) by default?" yes
	START_SSHD=$resp

	APERTURE=
	resp=
	START_XDM=
	if [[ -n $(scan_dmesg '/^wsdisplay[0-9]* /s/ .*//p') ]]; then
		if [[ -n $(scan_dmesg '/^[a-z]*[01]: aperture needed/p') ]]; then
			ask_yn "Do you expect to run the X Window System?" yes &&
				APERTURE=$MDXAPERTURE
		fi
		if [[ -n $MDXDM && $resp != n ]]; then
			ask_yn "Do you want the X Window System to be started by xenodm(1)?"
			START_XDM=$resp
		fi
	fi

	if [[ -n $CDEV ]]; then
		_d=${CPROM:-$CDEV}
		[[ -n $CONSOLE ]] && _cdef=yes
		ask_yn "Change the default console to $_d?" $_cdef
		DEFCONS=$resp
		if [[ $resp == y ]]; then
			ask_which "speed" "should $_d use" \
				"9600 19200 38400 57600 115200" $CSPEED
			case $resp in
			done)	DEFCONS=n;;
			*)	CSPEED=$resp;;
			esac
		fi
	fi
}

user_setup() {
	local _q="Setup a user? (enter a lower-case loginname, or 'no')"

	while :; do
		ask "$_q" no
		case $resp in
		n|no)	return
			;;
		y|yes)	_q="No really, what is the lower-case loginname, or 'no'?"
			continue
			;;
		root|daemon|operator|bin|build|sshd|www|nobody|ftp)
			;;
		[a-z]*([-a-z0-9_]))
			((${#resp} <= 31)) && break
			;;
		esac
		echo "$resp is not a usable loginname."
	done
	ADMIN=$resp
	while :; do
		ask "Full name for user $ADMIN?" "$ADMIN"
		case $resp in
		*[:\&,]*)
			echo "':', '&' or ',' are not allowed."
			;;
		*)
			((${#resp} <= 100)) && break
			echo "Too long."
			;;
		esac
	done
	ADMIN_NAME=$resp

	ask_password "Password for user $ADMIN?"
	ADMIN_PASS=$_password

	ADMIN_KEY=
	$AI && ask "Public ssh key for user $ADMIN" none &&
		[[ $resp != none ]] && ADMIN_KEY=$resp
}

ask_root_sshd() {
	typeset -l _resp

	[[ $START_SSHD == y ]] || return

	if [[ -z $ADMIN ]]; then
		echo "Since no user was setup, root logins via sshd(8) might be useful."
	fi
	echo "WARNING: root is targeted by password guessing attacks, pubkeys are safer."
	while :; do
		ask "Allow root ssh login? (yes, no, prohibit-password)" no
		_resp=$resp
		case $_resp in
		y|yes)	SSHD_ENABLEROOT=yes
			;;
		n|no)	SSHD_ENABLEROOT=no
			;;
		w|p|without-password|prohibit-password)
			SSHD_ENABLEROOT=prohibit-password
			;;
		*)	echo "'$resp' is not a valid choice."
			$AI && exit 1
			continue
			;;
		esac
		break
	done
}

set_timezone() {
	local _zonefile=$1 _zonepath _zsed _zoneroot=/usr/share/zoneinfo

	[[ ! -f $_zonefile ]] && return

	[[ -n $TZ ]] && return

	if [[ -h /mnt/etc/localtime ]]; then
		TZ=$(ls -l /mnt/etc/localtime 2>/dev/null)
		TZ=${TZ#*${_zoneroot#/mnt}/}
	fi

	wait_cgiinfo
	isin "$CGI_TZ" $(<$_zonefile) && TZ=$CGI_TZ

	[[ $_zonefile == /var/tzlist && -z $TZ ]] && return

	while :; do
		ask "What timezone are you in? ('?' for list)" "$TZ"
		_zonepath=${resp%%*(/)}
		case $_zonepath in
		"")	continue
			;;
		"?")	grep -v /. $_zonefile | show_cols
			continue
			;;
		esac

		while isin "$_zonepath/" $(<$_zonefile); do
			ask "What sub-timezone of '$_zonepath' are you in? ('?' for list)"
			_zsed=$(echo $_zonepath/ | sed 's,/,\\/,g')
			resp=${resp%%*(/)}
			case $resp in
			"")	;;
			"?")	sed -n "/^$_zsed/{s/$_zsed//;/\/./!p;}" $_zonefile | show_cols;;
			*)	_zonepath=$_zonepath/$resp;;
			esac
		done

		if isin "$_zonepath" $(<$_zonefile); then
			TZ=${_zonepath#$_zoneroot}
			return
		fi

		echo -n "'${_zonepath}'"
		echo " is not a valid timezone on this system."
	done
}

is_rootdisk() {
	local _d=$1 _rc=1

	make_dev $_d
	if disklabel $_d | grep -q '^  a: .*4\.2BSD ' &&
		mount -t ffs -r /dev/${_d}a /mnt; then
		if $UU; then
			ls -d /mnt/{auto_upgrade.conf,bin,dev,etc,home,sbin,tmp,usr,var}
		else
			ls -d /mnt/{bin,dev,etc,home,sbin,tmp,usr,var}
		fi
		_rc=$?
		umount /mnt
	fi >/dev/null 2>&1
	rm -f /dev/{r,}$_d?

	return $_rc
}

get_rootinfo() {
	local _rootdisks=$(get_dkdevs_root) _dkdev
	local _q="Which disk is the root disk? ('?' for details)"

	
	if [[ $MODE == install ]]; then
		for _dkdev in $_rootdisks; do
			diskinfo $_dkdev | grep -q '(0\..*G)$' &&
				_rootdisks="$(rmel "$_dkdev" $_rootdisks) $_dkdev"
		done
	fi

	while :; do
		echo "Available disks are: $(get_dkdevs_root | sed 's/^$/none/')."
		_ask "$_q" $_rootdisks || continue
		case $resp in
		"?")	diskinfo $(get_dkdevs);;
		'')	;;
		*)	# Translate $resp to disk dev name in case it is a DUID.
			_dkdev=$(get_dkdev_name "$resp")
			if isin "$_dkdev" $(get_dkdevs); then
				[[ $MODE == install ]] && break
				is_rootdisk "$_dkdev" && break
				echo "$resp is not a valid root disk."
				_rootdisks="$(rmel "$_dkdev" $_rootdisks) $_dkdev"
			else
				echo "no such disk"
			fi
			;;
		esac
		$AI && exit 1
	done
	log_answers "$_q" "$resp"

	make_dev $_dkdev || exit

	ROOTDISK=$_dkdev
	ROOTDEV=${ROOTDISK}a
	SWAPDEV=${ROOTDISK}b
}

parse_hn_line() {
	local _af=0 _name=1 _mask=2 _bc=3 _prefix=2 _c _cmd _prev _daddr _dhcp _i
	local _has_dhcp=false _has_inet6=false
	set -A _c -- "$@"
	set -o noglob

	ifconfig $_if inet6 >/dev/null 2>&1 && _has_inet6=true
	[[ -x /sbin/dhcpleased ]] && _has_dhcp=true

	case ${_c[_af]} in
	''|*([[:blank:]])'#'*)
		return
		;;
	inet)	((${#_c[*]} > 1)) || return
		if [[ ${_c[_name]} == autoconf ]]; then
			_cmds[${#_cmds[*]}]="ifconfig $_if ${_c[@]}"
			V4_AUTOCONF=true
			return
		fi
		[[ ${_c[_name]} == alias ]] && _mask=3 _bc=4
		[[ -n ${_c[_mask]} ]] && _c[_mask]="netmask ${_c[_mask]}"
		if [[ -n ${_c[_bc]} ]]; then
			_c[_bc]="broadcast ${_c[_bc]}"
			[[ ${_c[_bc]} == *NONE ]] && _c[_bc]=
		fi
		_cmds[${#_cmds[*]}]="ifconfig $_if ${_c[@]}"
		;;
	inet6)	! $_has_inet6 && return
		((${#_c[*]} > 1)) || return
		if [[ ${_c[_name]} == autoconf ]]; then
			_cmds[${#_cmds[*]}]="ifconfig $_if ${_c[@]}"
			V6_AUTOCONF=true
			return
		fi
		[[ ${_c[_name]} == alias ]] && _prefix=3
		[[ -n ${_c[_prefix]} ]] && _c[_prefix]="prefixlen ${_c[_prefix]}"
		_cmds[${#_cmds[*]}]="ifconfig $_if ${_c[@]}"
		;;
	dest)	((${#_c[*]} == 2)) && _daddr=${_c[1]} || return
		! $_has_inet6 && [[ $_daddr == @(*:*) ]] && return
		_prev=$((${#_cmds[*]} - 1))
		((_prev >= 0)) || return
		set -A _c -- ${_cmds[_prev]}
		_name=3
		[[ ${_c[_name]} == alias ]] && _name=4
		_c[_name]="${_c[_name]} $_daddr"
		_cmds[$_prev]="${_c[@]}"
		;;
	dhcp)	! $_has_dhcp && return
		_cmds[${#_cmds[*]}]="ifconfig $_if inet autoconf"
		V4_AUTOCONF=true
		;;
	'!'*)
		return
		;;
	*)	_cmds[${#_cmds[*]}]="ifconfig $_if ${_c[@]}"
		;;
	esac
	unset _c
	set +o noglob
}

ifstart() {
	local _if=$1 _lladdr _hn=/mnt/etc/hostname.$1 _cmds _i=0 _line
	set -A _cmds

	if [[ $_if == +([[:alpha:]])+([[:digit:]]) ]]; then
		_lladdr=$(if_name_to_lladdr $_if)
		[[ -n $_lladdr && -f /mnt/etc/hostname.$_lladdr ]] && return
	elif [[ $_if == ??:??:??:??:??:?? ]]; then
		_lladdr=$_if
		_if=$(ifconfig -M $_lladdr)
		[[ -z $_if ]] && return
	else
		return
	fi

	{ ifconfig $_if || ifconfig $_if create; } >/dev/null 2>&1 || return

	((NIFS++))

	set -o noglob
	while IFS= read -- _line; do
		parse_hn_line $_line
	done <$_hn

	while ((_i < ${#_cmds[*]})); do
		eval "${_cmds[_i]}"
		((_i++))
	done
	unset _cmds
	set +o noglob
}

enable_ifs() {
	local _gw _v4set=false _v6set=false _hn _if _trunks _svlans _vlans

	ifconfig lo0 inet 127.0.0.1/8

	for _hn in /mnt/etc/hostname.*; do
		_if=${_hn#/mnt/etc/hostname.}
		if isin "${_if%%+([0-9])}" $(ifconfig -C); then
			case ${_if%%+([0-9])} in
			trunk)	_trunks="$_trunks $_if";;
			svlan)	_svlans="$_svlans $_if";;
			vlan)	_vlans="$_vlans $_if";;
			esac
		elif [[ $_if == ??:??:??:??:??:?? ]]; then
			ifstart $_if
		else
			ifconfig $_if >/dev/null 2>&1 && ifstart $_if
		fi
	done
	for _if in $_trunks $_svlans $_vlans; do
		ifstart $_if
	done

	stripcom /mnt/etc/mygate |
	while read _gw; do
		case $_gw in
		'!'*)
			continue
			;;
		!(*:*))
			($_v4set || $V4_AUTOCONF) && continue
			route -qn add -host default $_gw
			_v4set=true
			;;
		*)
			($_v6set || $V6_AUTOCONF) && continue
			route -qn add -host -inet6 default $_gw
			_v6set=true
			;;
		esac
	done

	route -qn add -net 127 127.0.0.1 -reject >/dev/null
}

enable_network() {
	local _f

	for _f in resolv.conf; do
		if [[ -f /mnt/etc/$_f ]]; then
			cp /mnt/etc/$_f /etc/$_f
		fi
	done

	echo "127.0.0.1\tlocalhost" >/tmp/i/hosts
	echo "::1\t\tlocalhost" >>/tmp/i/hosts

	enable_ifs
}

start_cgiinfo() {
	((NIFS < 1)) && return

	add_hostent 199.185.178.80 ftplist1.openbsd.org
	add_hostent 2620:3d:c000:178::80 ftplist1.openbsd.org

	set -m
	(
		unpriv2 ftp -w 15 -Vao - \
			"$HTTP_PROTO://ftplist1.openbsd.org/cgi-bin/ftplist.cgi?dbversion=1" \
			2>/dev/null >$CGI_INFO

		echo -n $SECONDS >$HTTP_SEC
		feed_random
	) &
	echo $! > /tmp/cgipid
	set +m

	(
		sleep 12;
		if [ -f /tmp/cgipid ]; then
			kill -INT -"$(</tmp/cgipid)" >/dev/null 2>&1
		fi
	) &
}

munge_fstab() {
	local _dev _mp _fstype _opt _rest

	while read _dev _mp _fstype _opt _rest; do
		[[ $_dev == @(/dev/vnd*|\#*) ||
			$_fstype == nfs ||
			! -f /sbin/mount_$_fstype ||
			$_opt == *noauto* ||
			$_opt == *xx* ]] && continue

		if [[ $_fstype == ffs ]]; then
			_opt=$(echo $_opt | sed 's/[[:<:]]ro[[:>:]]/rw/')
		else
			_opt=$(echo $_opt | sed 's/[[:<:]]rw[[:>:]]/ro/')
		fi

		echo $_dev /mnt${_mp%/} $_fstype $_opt $_rest

	done </tmp/i/fstab >/etc/fstab

	if [[ ! -s /etc/fstab ]]; then
		echo "Unable to create valid /etc/fstab."
		exit
	fi
}

check_fs() {
	local _dev _dn _mp _fstype _rest _fail _f _passno

	ask_yn "Force checking of clean non-root filesystems?" && _f=f

	while read _dev _mp _fstype _rest _rest _passno _rest; do
		_dn=$(get_dkdev_name "$_dev")
		[[ $ROOTDEV == @(${_dev#/dev/}|$_dn${_dev##*.}) ]] && continue
		[[ -f /sbin/fsck_$_fstype ]] || continue
		make_dev "$_dn" || continue
		((_passno > 0)) || continue
		echo -n "fsck -${_f}p $_dev..."
		if ! fsck -${_f}p $_dev >/dev/null 2>&1; then
			echo " FAILED. You must fsck $_dev manually."
			_fail=y
		else
			echo " OK."
		fi
	done </etc/fstab

	[[ -n $_fail ]] && exit
}

mount_fs() {
	local _async=$1 _dev _mp _fstype _opt _rest _msg _fail

	while read _dev _mp _fstype _opt _rest; do
		[[ $_mp == /mnt ]] || mkdir -p $_mp

		_msg=$(mount -v -t $_fstype $_async -o $_opt $_dev $_mp) ||
			_fail="$_fail\n$_mp ($_dev)"
		echo $_msg | sed 's/, ctime=[^,)]*//'
	done </etc/fstab

	if [[ -n $_fail ]]; then
		echo "\nWARNING! The following filesystems were not properly mounted:$_fail"
		ask_yn "Continue anyway?" || exit
	fi
}

feed_random() {
	(dmesg; cat $CGI_INFO /*.conf; sysctl; route -n show; df;
		ifconfig -A; hostname) >/dev/random 2>&1
	if [[ -e /mnt/var/db/host.random ]]; then
		dd if=/mnt/var/db/host.random of=/dev/random bs=65536 count=1 \
			status=none
	fi
}

install_sets() {
	local _cddevs=$(get_cddevs) _d=$CGI_METHOD _im _locs=disk _src

        if [[ -n $(get_ifs) ]]; then
		_locs="$_locs http"

		[[ -x /sbin/mount_nfs ]] && _locs="$_locs nfs"

		[[ -s /mnt/etc/installurl ]] && _d=http

		: ${_d:=http}
	fi

	[[ -n $_cddevs ]] && : ${_d:=cd0}

	: ${_d:=disk}

	if ! isin "$_d" $_cddevs $_locs; then
		for _src in http $_cddevs nfs disk; do
			isin "$_src" $_cddevs $_locs && _d=$_src && break
		done
	fi

	echo "\nLet's $MODE the sets!"
	while :; do
		_cddevs=$(get_cddevs)
		umount -f /mnt2 >/dev/null 2>&1

		ask "Location of sets? (${_cddevs:+$_cddevs }$_locs or 'done')" "$_d"
		case $resp in
		done)	sane_install && return
			;;
		[cC]*)	if [[ -n $_cddevs ]]; then
				set -- $_cddevs
				[[ $resp == [cC]?([dD]) ]] && resp=$1
				_im=$resp
				install_cdrom $resp && INSTALL_METHOD=$_im
			fi
			;;
		[dD]*)	install_disk && INSTALL_METHOD=disk
			;;
		[hH]*)	isin http $_locs && install_http && INSTALL_METHOD=http
			;;
		[nN]*)	isin nfs $_locs && install_nfs && INSTALL_METHOD=nfs
			;;
		*)	$AI && err_exit "'$resp' is not a valid choice."
			;;
		esac

		[[ -n $INSTALL_METHOD ]] && _d=$INSTALL_METHOD

		if [ -x /mnt/usr/sbin/fw_update -a \
		    "$(echo /mnt2/*firmware*tgz)" != "/mnt2/*firmware*tgz" ]; then
			DESTDIR=/mnt /mnt/usr/sbin/fw_update /mnt2/*firmware*tgz
			enable_ifs	# try again with firmwares
		fi

		sane_install quiet || $AI && _d=done
	done
}

apply() {
	if [[ $START_SSHD == n ]]; then
		echo "sshd_flags=NO" >>/mnt/etc/rc.conf.local
	elif [[ -n $SSHD_ENABLEROOT ]]; then
		if ! grep -q "^#PermitRootLogin $SSHD_ENABLEROOT\$" \
				/mnt/etc/ssh/sshd_config; then
			sed -i "s/^#\(PermitRootLogin\) .*/\1 $SSHD_ENABLEROOT/" \
				/mnt/etc/ssh/sshd_config
		fi
	fi

	[[ -n $APERTURE ]] &&
		echo "machdep.allowaperture=$APERTURE # See xf86(4)" \
			>>/mnt/etc/sysctl.conf

	[[ $START_XDM == y && -x /mnt/usr/X11R6/bin/xenodm ]] &&
		echo "xenodm_flags=" >>/mnt/etc/rc.conf.local

	if [[ $DEFCONS == y ]]; then
		cp /mnt/etc/ttys /tmp/i/ttys
		sed	-e "/^console/s/on  secure/off secure/" \
			-e "/^$CTTY/s/std.9600/std.${CSPEED}/" \
			-e "/^$CTTY/s/std.115200/std.${CSPEED}/" \
			-e "/^$CTTY/s/unknown/vt220	/" \
			-e "/$CTTY/s/off.*/on secure/" /tmp/i/ttys >/mnt/etc/ttys
		[[ -n $CPROM ]] &&
			echo "stty $CPROM $CSPEED\nset tty $CPROM" \
				>>/mnt/etc/boot.conf
	fi

	ln -sf /usr/share/zoneinfo/$TZ /mnt/etc/localtime
}

encr_pwd() {
	local _p=$1

	if [[ -z $_p ]]; then
		echo '*'
	elif [[ $_p == \$2?\$[0-9][0-9]\$* && ${#_p} > 40 ||
		$_p == '*************' ]]; then
		echo "$_p"
	else
		encrypt -b a -- "$_p"
	fi
}

store_random() {
	local _bootseed=/mnt/etc/random.seed _hostseed=/mnt/var/db/host.random

	dd if=/dev/random of=$_bootseed bs=512   count=1 status=none
	dd if=/dev/random of=$_hostseed bs=65536 count=1 status=none

	chmod u=rw-t,go= $_bootseed $_hostseed
}

finish_up() {
	local _dev _mp _fstype _rest _d
	local _kernel_dir=/mnt/usr/share/relink/kernel
	local _kernel=${MDKERNEL:-GENERIC} _syspatch_archs="amd64 arm64 i386"

	if [[ -x /mnt/sbin/swapctl ]]; then
		/mnt/sbin/swapctl -a /dev/$SWAPDEV >/dev/null 2>&1
		while read _dev _mp _fstype _rest; do
			[[ $_fstype == swap ]] &&
				/mnt/sbin/swapctl -a $_dev >/dev/null 2>&1
		done </mnt/etc/fstab
	fi

	if [[ ! -f /mnt/etc/installurl ]]; then
		echo "${INSTALL_URL:-https://cdn.openbsd.org/pub/OpenBSD}" \
			>/mnt/etc/installurl
	fi

	echo -n "Making all device nodes..."
	(cd /mnt/dev; sh MAKEDEV all
		for _dev in $(get_dkdevs) $(get_cddevs); do
			sh MAKEDEV $_dev
		done
	)
	echo " done."

	rm -f /mnt/var/run/ld.so.hints

	if [[ $MODE == install ]]; then
		mkdir -p /mnt/usr/{src,{,x}obj} && (
			cd /mnt/usr
			chmod 770 {,x}obj
			chown build:wobj {,x}obj
			chmod 775 src
			chown root:wsrc src
		)
	fi

	make_dev $(get_softraid_chunks $ROOTDISK)
	md_installboot $ROOTDISK

	chmod og-rwx /mnt/bsd{,.mp,.rd} 2>/dev/null
	if [[ -f /mnt/bsd.mp ]] && ((NCPU > 1)); then
		_kernel=$_kernel.MP
		echo "Multiprocessor machine; using bsd.mp instead of bsd."
		mv /mnt/bsd /mnt/bsd.sp 2>/dev/null
		mv /mnt/bsd.mp /mnt/bsd
	fi

	sha256 /mnt/bsd | (umask 077; sed 's,/mnt,,' >/mnt/var/db/kernel.SHA256)

	[[ $MODE == upgrade ]] &&
		echo "/usr/sbin/sysmerge -b" >>/mnt/etc/rc.sysmerge

	[[ -n $http_proxy ]] &&
		quote export "http_proxy=$http_proxy" >>/mnt/etc/rc.firsttime

	echo "/usr/sbin/fw_update" >>/mnt/etc/rc.firsttime

	isin "$ARCH" $_syspatch_archs && cat <<'__EOT' >>/mnt/etc/rc.firsttime
set -A _KERNV -- $(sysctl -n kern.version |
	sed 's/^OpenBSD \([1-9][0-9]*\.[0-9]\)\([^ ]*\).*/\1 \2/;q')
if ((${#_KERNV[*]} == 1)); then
	echo "Checking for available binary patches..."
	_CKPATCH=$(syspatch -c)
	if [[ -n $_CKPATCH ]]; then
		echo "Run syspatch(8) to install:"
		echo "$_CKPATCH" | column -xc 80
	fi
fi
__EOT

	if [[ -x /mnt/usr/sbin/fw_update ]]; then
		DESTDIR=/mnt /mnt/usr/sbin/fw_update
		typeset -f md_fw >/dev/null && md_fw $ROOTDISK apple-boot
	fi

	if [[ -f $_kernel_dir.tgz ]]; then
		echo -n "Relinking to create unique kernel..."
		(
		set -e
		rm -rf $_kernel_dir
		mkdir -m 700 -p $_kernel_dir
		tar -C $_kernel_dir -xzf $_kernel_dir.tgz $_kernel
		rm -f $_kernel_dir.tgz
		chroot /mnt /bin/ksh -e -c "cd ${_kernel_dir#/mnt}/$_kernel
			make newbsd
			[ -f /etc/bsd.re-config ] &&
				config -e -c /etc/bsd.re-config -f bsd
			make newinstall"
		) >/dev/null 2>&1 && echo " done." || echo " failed."
	fi

	prep_root_mail /tmp/i/$MODE.resp "$(hostname) $MODE response file"

	if [[ -x /mnt/$MODE.site ]]; then
		if ! chroot /mnt /$MODE.site; then
			store_random
			err_exit "$MODE.site failed"
		fi
	fi

	store_random

	cat <<__EOT

CONGRATULATIONS! Your OpenBSD $MODE has been successfully completed!

__EOT
	if [[ $MODE == install ]]; then
		cat <<'__EOT'
When you login to your new system the first time, please read your mail
using the 'mail' command.

__EOT

		md_congrats
	fi

	$AI && >/tmp/ai/ai.done
}

do_autoinstall() {
	rm -f /tmp/ai/ai.done

	echo "Performing non-interactive $AI_MODE..."
	/$AI_MODE -af /tmp/ai/ai.$AI_MODE.conf 2>&1 </dev/null |
		tee /dev/stderr | sed "s/^.*$(echo '\r')//" >/tmp/ai/ai.log

	$UU || [[ -f /tmp/ai/ai.done ]] || 
		err_exit "failed; check /tmp/ai/ai.log"

	prep_root_mail /tmp/ai/ai.log "$(hostname) $AI_MODE log"

	while :; do
		ask "Exit to (S)hell, (H)alt or (R)eboot?" reboot
		case $resp in
		[hH]*)	exec halt;;
		[rR]*)	exec reboot;;
		[sS]*)	break;;
		esac
	done

	echo "To boot the new system, enter 'reboot' at the command prompt."
	exit
}

pick_keydisk() {
	KEYDISK=
	local _disk _label _parts

	ask_which disk 'contains the key disk' '$(rmel $ROOTDISK $(get_dkdevs))'
	[[ $resp == done ]] && return 1
	_disk=$resp

	make_dev $_disk
	_parts=$(disklabel $_disk | sed -En "/RAID/s/^  ([$PARTITIONS]): .*/\1/p")
	if [[ -z $_parts ]]; then
		echo "$_disk must contain a RAID partition."
		return 1
	fi

	ask_which "$_disk partition" 'is the key disk' "$_parts"
	[[ $resp == done ]] && return 1
	_label=$resp
	KEYDISK=$_disk$_label
}

encrypt_root() {
	local _args _chunk=$ROOTDISK

	[[ $MDBOOTSR == y ]] || return

	[[ -x /sbin/bioctl ]] || return

	[[ -z $(get_softraid_volumes) ]] || return

	while :; do
		ask 'Encrypt the root disk with a (p)assphrase or (k)eydisk?' no
		case $resp in
		[kK]*)
			pick_keydisk || continue
			_args=-k$KEYDISK
			break
			;;
		[pP]*)  $AI || break
			ask_passphrase 'New passphrase?'
			_args=-s
			break
			;;
		[nN]*)	return
			;;
		*)	echo "'$resp' is not a valid choice."
			;;
		esac
	done

	echo "\nConfiguring the crypto chunk $_chunk...\n"
	md_prep_fdisk $_chunk
	echo 'RAID *' | disklabel -w -A -T- $_chunk

	print -r -- "$_passphrase" |
		bioctl -Cforce -cC -l${_chunk}a $_args softraid0 >/dev/null
	unset _passphrase

	ROOTDISK=$(get_softraid_volumes)
	ROOTDEV=${ROOTDISK}a
	SWAPDEV=${ROOTDISK}b
	echo "\nConfiguring the root disk $ROOTDISK...\n"
}

do_install() {
	local _rootkey _rootpass

	while :; do
		ask_until "System hostname? (short form, e.g. 'foo')" \
			"$(hostname -s)"
		[[ $resp != *+([[:cntrl:]]|[[:space:]])* ]] && break
		echo "Invalid hostname."
		$AI && exit 1
	done
	[[ ${resp%%.*} != $(hostname -s) ]] && hostname "$resp"
	ALLSETS="$ALLSETS site$VERSION-$(hostname -s).tgz"
	export PS1='\h# '

	echo

	donetconfig

	start_cgiinfo

	echo

	while :; do
		ask_password "Password for root account?"
		_rootpass="$_password"
		[[ -n "$_password" ]] && break
		echo "The root password must be set."
	done

	_rootkey=
	if $AI; then
		ask "Public ssh key for root account?" none
		[[ $resp != none ]] && _rootkey=$resp
	fi

	questions

	user_setup
	ask_root_sshd

	set_timezone /var/tzlist

	echo

	get_rootinfo

	encrypt_root

	DISKS_DONE=
	FSENT=

	rm -f /tmp/i/fstab*

	while :; do
		if ! isin "$ROOTDISK" $DISKS_DONE; then
			resp=$ROOTDISK
			rm -f /tmp/i/fstab
		else
			ask_which "disk" "do you wish to initialize" \
				'$(get_dkdevs_uninitialized)' done
			[[ $resp == done ]] && break
		fi
		_disk=$resp
		configure_disk $_disk || continue
		DISKS_DONE=$(addel $_disk $DISKS_DONE)
	done

	for _mp in $(bsort $FSENT); do
		_pp=${_mp##*!}
		_mp=${_mp%!*}
		echo -n "$_pp $_mp ffs rw"

		[[ $_mp == / ]] && { echo " 1 1"; continue; }

		echo -n ",nodev"

		case $_mp in
		/sbin|/usr)			;;
		/usr/bin|/usr/sbin)		;;
		/usr/libexec|/usr/libexec/*)	;;
		/usr/local|/usr/local/*)	;;
		/usr/X11R6|/usr/X11R6/bin)	;;
		*)	echo -n ",nosuid"	;;
		esac
		echo " 1 2"
	done >>/tmp/i/fstab

	munge_fstab

	mount_fs "-o async"

	feed_random

	install_sets

	_mp=$(df /mnt/usr/local | sed '$!d')
	_mp=${_mp##*/mnt}
	sed -i "s#\(${_mp:-/} ffs rw\)#\1,wxallowed#" /tmp/i/fstab

	if [[ -z $TZ ]]; then
		(cd /mnt/usr/share/zoneinfo
			ls -1dF $(tar cvf /dev/null [A-Za-y]*) >/mnt/tmp/tzlist )
		echo
		set_timezone /mnt/tmp/tzlist
		rm -f /mnt/tmp/tzlist
	fi

	if _time=$(http_time) && _now=$(date +%s) &&
		(( _now - _time > 120 || _time - _now > 120 )); then
		ln -sf /mnt/usr/share/zoneinfo/$TZ /etc/localtime
		if ask_yn "Time appears wrong.  Set to '$(date -r "$(http_time)")'?" yes; then
			date $(date -r "$(http_time)" "+%Y%m%d%H%M.%S") >/dev/null
		fi
		rm -f /etc/localtime
	fi

	if [[ -s $HTTP_LIST ]]; then
		_i=${INSTALL_URL:+install=$INSTALL_URL&}
		_i=$_i${TZ:+TZ=$TZ&}
		_i=$_i${INSTALL_METHOD:+method=$INSTALL_METHOD}
		_i=${_i%&}
		[[ -n $_i ]] && unpriv2 ftp -w 15 -Vao - \
			"$HTTP_PROTO://ftplist1.openbsd.org/cgi-bin/ftpinstall.cgi?dbversion=1&$_i" \
			 >/dev/null 2>&1 &
	fi

	sed "/^console.*on.*secure.*$/s/std\.[0-9]*/std.$(stty speed </dev/console)/" \
		/mnt/etc/ttys >/tmp/i/ttys
	mv /tmp/i/ttys /mnt/etc/ttys

	echo -n "Saving configuration files..."

	(cd /var/db/dhcpleased; for _f in *; do
		[[ -f $_f ]] && mv $_f /mnt/var/db/dhcpleased/.
	done)

	hostname >/tmp/i/myname


	echo "127.0.0.1\tlocalhost" >/mnt/etc/hosts
	echo "::1\t\tlocalhost" >>/mnt/etc/hosts

	if [[ -f /tmp/i/hosts ]]; then
		_dn=$(get_fqdn)
		while read _addr _hn _aliases; do
			[[ $_hn == ftplist[0-9].openbsd.org ]] && continue
			if [[ -n $_aliases || $_hn != ${_hn%%.*} || -z $_dn ]]; then
				echo "$_addr\t$_hn $_aliases"
			else
				echo "$_addr\t$_hn.$_dn $_hn"
			fi
		done </tmp/i/hosts >>/mnt/etc/hosts
		rm /tmp/i/hosts
	fi

	(cd /tmp/i; for _f in fstab hostname* kbdtype my* ttys *.conf; do
		[[ -f $_f && -s $_f ]] && mv $_f /mnt/etc/.
	done)
	[[ -s /etc/resolv.conf ]] && cp /etc/resolv.conf /mnt/etc/resolv.conf

	echo " done."

	apply

	if [[ -n $ADMIN ]]; then
		_encr=$(encr_pwd "$ADMIN_PASS")
		_home=/home/$ADMIN
		uline="${ADMIN}:${_encr}:1000:1000:staff:0:0:${ADMIN_NAME}:$_home:/bin/ksh"
		echo "$uline" >>/mnt/etc/master.passwd
		echo "${ADMIN}:*:1000:" >>/mnt/etc/group
		echo $ADMIN >/mnt/root/.forward

		_home=/mnt$_home
		mkdir -p $_home
		(cd /mnt/etc/skel; pax -rw -k -pe . $_home)
		(umask 077 && sed "s,^To: root\$,To: ${ADMIN_NAME} <${ADMIN}>," \
			/mnt/var/mail/root >/mnt/var/mail/$ADMIN )
		chown -R 1000:1000 $_home /mnt/var/mail/$ADMIN
		sed -i -e "s@^wheel:.:0:root\$@wheel:\*:0:root,${ADMIN}@" \
			/mnt/etc/group 2>/dev/null

		[[ -n "$ADMIN_KEY" ]] &&
			print -r -- "$ADMIN_KEY" >>$_home/.ssh/authorized_keys
	fi

	if [[ -n "$_rootpass" ]]; then
		_encr=$(encr_pwd "$_rootpass")
		sed -i -e "s@^root::@root:${_encr}:@" /mnt/etc/master.passwd \
			2>/dev/null
	fi
	pwd_mkdb -p -d /mnt/etc /etc/master.passwd

	[[ -n "$_rootkey" ]] && (
		umask 077
		print -r -- "$_rootkey" >>/mnt/root/.ssh/authorized_keys
	)

	finish_up
}

do_upgrade() {
	local _f

	get_rootinfo

	echo -n "Checking root filesystem (fsck -fp /dev/$ROOTDEV)..."
	fsck -fp /dev/$ROOTDEV >/dev/null 2>&1 || { echo "FAILED."; exit; }
	echo " OK."

	echo -n "Mounting root filesystem (mount -o ro /dev/$ROOTDEV /mnt)..."
	mount -o ro /dev/$ROOTDEV /mnt || { echo "FAILED."; exit; }
	echo " OK."

	for _f in /mnt/etc/{fstab,myname}; do
		[[ -f $_f ]] || { echo "No $_f!"; exit; }
		cp $_f /tmp/i/${_f##*/}
	done

	hostname $(stripcom /tmp/i/myname)
	ALLSETS="$ALLSETS site$VERSION-$(hostname -s).tgz"
	export PS1='\h# '

	enable_network

	munge_fstab

	umount /mnt || { echo "Can't umount $ROOTDEV!"; exit; }

	start_cgiinfo

	check_fs

	mount_fs

	rm -f /mnt/bsd.upgrade /mnt/auto_upgrade.conf

	feed_random

	wait_cgiinfo

	install_sets

	finish_up
	if [ -f /tmp/wdpid ]; then
		kill -KILL "$(</tmp/wdpid)" 2>/dev/null
		rm -f /tmp/wdpid
	fi
}

check_unattendedupgrade() {
	local _d=$(get_dkdevs_root) _rc=1

	_d=${_d%% *}
	if [[ -n $_d ]]; then
		make_dev $_d
		if mount -t ffs -r /dev/${_d}a /mnt 2>/dev/null; then
			[[ -f /mnt/bsd.upgrade && -f /mnt/auto_upgrade.conf ]]
			_rc=$?
			((_rc == 0)) && cp /mnt/auto_upgrade.conf /
			echo "Which disk is the root disk = ${_d}" >> /auto_upgrade.conf
			umount /mnt
		fi
		rm -f /dev/{r,}$_d?
	fi

	return $_rc
}

WATCHDOG_PERIOD_SEC=$((30 * 60))

reset_watchdog() {
	local _pid
	if [ -f /tmp/wdpid ]; then
		_pid=$(</tmp/wdpid)
		kill -KILL -$_pid 2>/dev/null
		wait $_pid 2>/dev/null
		rm -f /tmp/wdpid
		start_watchdog
	fi
}

start_watchdog() {
	set -m
	(
		sleep $WATCHDOG_PERIOD_SEC && echo WATCHDOG > /dev/tty && reboot
	) >/dev/null 2>&1 &
	echo $! > /tmp/wdpid
	set +m
}

[[ -n $FUNCS_ONLY ]] && return



PARTITIONS=a-p
(( $(sysctl -n kern.maxpartitions) == 52 )) && PARTITIONS=a-zA-Z

AI=false
UU=false
MODE=
PROGNAME=${0##*/}
AI_RESPFILE=
while getopts "af:x" opt; do
	case $opt in
	a)	AI=true;;
	f)	AI_RESPFILE=$OPTARG;;
	x)	UU=true;;
	*)	usage;;
	esac
done
shift $((OPTIND-1))
(($# == 0)) || usage

if [[ -z $MODE ]]; then
	case $PROGNAME in
	autoinstall)		AI=true;;
	install|upgrade)	MODE=$PROGNAME;;
	*)			exit 1;;
	esac
fi

for _opt in d f l m n p s; do
	ulimit -$_opt unlimited
done

cd /
umount -af >/dev/null 2>&1

DMESGBOOT=/var/run/dmesg.boot
dmesgtail >$DMESGBOOT

. install.md

start_dmesg_listener

CGI_INFO=/tmp/i/cgiinfo
CGI_METHOD=
CGI_TIME=
CGI_TZ=
export EDITOR=ed
HTTP_DIR=
HTTP_LIST=/tmp/i/httplist
HTTP_SEC=/tmp/i/httpsec
INSTALL_METHOD=
NIFS=0
export PS1="$MODE# "
PUB_KEY=/etc/signify/openbsd-${VERSION}-base.pub
ROOTDEV=
ROOTDISK=
SETDIR="$VNAME/$ARCH"
UPGRADE_BSDRD=false
V4_AUTOCONF=false
V6_AUTOCONF=false
WLANLIST=/tmp/i/wlanlist

HTTP_SETDIR=$SETDIR
set -- $(scan_dmesg "/^OpenBSD $VNAME\([^ ]*\).*$/s//\1/p")
[[ $1 == -!(stable) ]] && HTTP_SETDIR=snapshots/$ARCH

if [[ -e /etc/ssl/cert.pem ]]; then
	FTP_TLS=true
	HTTP_PROTO=https
else
	FTP_TLS=false
	HTTP_PROTO=http
fi

CONSOLE=$(scan_dmesg '/^\([^ ]*\).*: console$/s//\1/p')
[[ -n $CONSOLE ]] && CSPEED=$(stty speed </dev/console)

md_consoleinfo

SETS=$(echo {base,comp,man,game,xbase,xshare,xfont,xserv}$VERSION.tgz)
DEFAULTSETS="${MDSETS:-bsd bsd.rd} $SETS"
ALLSETS="${MDSETS:-bsd bsd.rd} $SETS site$VERSION.tgz"
SANESETS="${MDSANESETS:-bsd} base${VERSION}.tgz"
if ((NCPU > 1)); then
	DEFAULTSETS="${MDSETS:-bsd bsd.mp bsd.rd} $SETS"
	ALLSETS="${MDSETS:-bsd bsd.mp bsd.rd} $SETS site$VERSION.tgz"
	SANESETS="${MDSANESETS:-bsd bsd.mp} base${VERSION}.tgz"
fi

export COLUMNS=$(stty -a </dev/console |
	sed -n '/columns/{s/^.* \([0-9]*\) columns.*$/\1/;p;}')
((COLUMNS == 0)) && COLUMNS=80

if ! $AI; then
	cat <<'__EOT'
At any prompt except password prompts you can escape to a shell by
typing '!'. Default answers are shown in []'s and are selected by
pressing RETURN.  You can exit this program at any time by pressing
Control-C, but this can leave your system in an inconsistent state.

__EOT
elif $UU; then
	check_unattendedupgrade || exit 1

	start_watchdog

	get_responsefile
	do_autoinstall
elif [[ -z $AI_RESPFILE ]]; then
	get_responsefile ||
		err_exit "No response file found; non-interactive mode aborted."

	do_autoinstall
else
	cp $AI_RESPFILE /tmp/ai/ai.conf || exit
fi

set_term

rm -f /tmp/i/$MODE.resp

case $MODE in
install)	do_install;;
upgrade)	do_upgrade;;
esac

$AI && exit

_d=reboot
[[ $MODE == install && $MDHALT == y ]] && _d=halt

while :; do
	ask "Exit to (S)hell, (H)alt or (R)eboot?" "$_d"
	case $resp in
	[hH]*)	exec halt;;
	[rR]*)	exec reboot;;
	[sS]*)	break;;
	esac
done

echo "To boot the new system, enter 'reboot' at the command prompt."
